<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on akagenorobin</title><link>https://akagenorobin.github.io/post/</link><description>Recent content in Posts on akagenorobin</description><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Wed, 27 Dec 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://akagenorobin.github.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>MAU・DAU・ヘビーユーザ数の関係性を考察してみた</title><link>https://akagenorobin.github.io/post/2023-12-27/</link><pubDate>Wed, 27 Dec 2023 00:00:00 +0000</pubDate><guid>https://akagenorobin.github.io/post/2023-12-27/</guid><description>問題設定 あるサービスの月間のユーザ数(= MAU)を N 、1日のユーザ数(= DAU)を M とする。 このサービスを月間20日以上利用しているユーザ数（= ヘビーユーザ数）は？
という問題を考察したのでメモ。
考察 MAU に含まれるユーザで1ヶ月（30日としておく）のうち x 日利用する人の割合を P(x) とおく。 求めたいのは
$$\sum_{x=20}^{30} NP(x)$$
である。DAU に含まれるユーザで1ヶ月のうち x 日利用する人の数は
$$NP(x) \times \frac{x}{30}$$
よって DAU は
$$M = \sum_{x=1}^{30} NP(x) \times \frac{x}{30}$$
と表せて、ここから1ユーザあたりの利用日数の期待値が
$$E[x] = \sum_{x=1}^{30} xP(x) = 30\frac{M}{N} = 30R$$
となることがわかる（ただし R = M/N とおいた）。 これ割と非自明な結果だと思ったんですが自明ですかね🤔 （例えば DAU と MAU の比率が 1:4 だったら1ユーザが1ヶ月に利用する期間の期待値が1週間ということ）
というわけで、 DAU と MAU の値からは分布の期待値しか決まらないことがわかったので、ヘビーユーザの数を推定するには分布を仮定する必要がある。 簡単のために指数分布
$$P(x)=\lambda e^{-\lambda x}$$
を仮定しよう。指数分布の期待値は
$$E[x]=\frac{1}{\lambda}$$</description></item><item><title>PO としての思考を開示してみる</title><link>https://akagenorobin.github.io/post/2023-08-21/</link><pubDate>Mon, 21 Aug 2023 00:00:00 +0000</pubDate><guid>https://akagenorobin.github.io/post/2023-08-21/</guid><description>今月から社内のとあるプロダクトの PO (プロダクトオーナー)になりました。
（任命したのは自分なのですが）
PO をやるのは今回で2回目になりますが、慣れて来たらプロダクトの全てをコントロールできる、とても楽しくてやりがいのあるポジションです。
そこで僕が PO をやる上で考えていること、実際やったこと、を言語化してみます。
PO って何すればいいの？ PO は「プロダクトオーナー」で、文字通り受け取ると「プロダクトについてオーナーシップを持っている人」です。 オーナーシップを持つ、とはどういうことかというと、それについて全責任を持つということです。
つまり PO という言葉はその人が持っている責任範囲について明示しているだけであり、業務内容については定めていません。
そして定められてる責任範囲とは「プロダクトに関わること全て」ということになります。
これを誤解して、 PO の業務は報告書を書くことだとか、プロダクトバックログの管理だとか、業務内容で PO という仕事を定めてしまうと、その仕事は無機質なものになるし、たぶん評価も上がらないでしょう。
PO の責任範囲は「プロダクトに関わること全て」なのだから、業務は当然「プロダクトに関わること全て」です。
チームには売り方を考える PdM (プロダクトマネージャー)や、マネジメントを担当する SM (スクラムマスター)などがいるので、業務範囲を分割すべき、という人もいるかもしれませんが、僕の意見は違います。
売り方を考えることもチームをマネジメントすることも「プロダクトに関わること」なのだから、それらは全て PO の責任範囲内です。
なので、それらは PO の業務ではない、ということはないです。
それがオーナーシップを持つということです。
もし業務の内容で PO の仕事に取り組んでいる人がいるなら、一旦その思考を切り替えてみたら、ちょっと世界が変わって見えるんじゃないでしょうか。
PO としての思考 僕が PO としてプロダクト開発をする上で、大事にしていることの優先順位は以下です。
チームメンバーが気持ち良く開発できること ユーザーがちゃんと使ってくれるものを作ること 売れるものを作ること 何故この優先順位なのかということを説明します。
チームメンバーが気持ち良く開発できること これが最も大事なのは、受注して開発して納品して終わり、という単発の受託案件ではなく、安定した品質でクラウドサービスを提供し続け、その対価としてサブスクリプションでお金をもらう、というビジネスモデルを取る場合です。
単発の開発ならそこまで品質に拘る必要もないし、それなりの人材を一時的に雇って開発しても何とかなるでしょう。
（そんなことねーよという突っ込みは一旦無視します）
ただし、クラウドサービスを提供するなら、リリースしたものは保守運用する必要があるし、ユーザが増えたらそれなりに大規模なシステムになってくるので、技術力も必要です。
であればスキルの高いメンバーには長く働いてもらう必要があるし、スキルの高いメンバーが働きたくなるような環境にする必要があります。
スキル云々を最初に書いてしまいましたが、そうではなくても人は気持ち良く仕事をしてるときの方がパフォーマンスが高いので、開発効率を考えてもこれは大事です。
あと、僕はそもそも自分自身が気持ち良く開発したいというモチベーションが高いです。
ユーザーがちゃんと使ってくれるものを作ること / 売れるものを作ること この2つの優先順位は会社のフェーズにもよると思いますが、僕はエンジニアがコミットすべきは「ユーザに使われること ＞ 売れること」だと思っています。
もちろん売上は事業を継続する上で大切ですが、そもそも売れるかどうかはビジネス戦略によるものが大きいというのと、売れても使われてないならそれは長くは続かない売上だからです。
ユーザの依存度が高いならその段階で売れていなくても例えば値上げすることもできますし、それをフックに広告を出すなど他のビジネス戦略も取れます。
なので PO として大事にしたいことは、ユーザにちゃんと作ってもらえているかどうか、そして次点で売上、というのが僕の思考です。
経営からの圧力、重要顧客の要望や解約など、この優先順位を狂わせようとするバイアスはたくさんあります。もちろんビジネス上の制約で優先順位を逆転せざるを得ないことはあるでしょう。しかし、圧力と戦って優先度を守り、プロダクトを正しい方向へ導くことが、エンジニアたる PO としての役目だと思っています。</description></item><item><title>ICFP-PC2022 参加記</title><link>https://akagenorobin.github.io/post/2022-09-20/</link><pubDate>Tue, 20 Sep 2022 00:00:00 +0000</pubDate><guid>https://akagenorobin.github.io/post/2022-09-20/</guid><description>今年も ICFP-PC にチーム chirijako で参加しました。 実は2017年から参加しているので、今年で6回目になります。 毎年楽しく参加させていただいています。
ICFP-PC とは 毎年開催されている72時間耐久のプログラミングコンテストです。
ICFP（国際関数型プログラミング学会）主催のコンテストですが、関数型言語に特化した問題が出るわけではなく、最近は割と普通のマラソンに近いです（過去にはラムダ計算を題材にした問題も出てましたが）。
一般的なコンテストと違うのは
プログラムを提出するわけではなく解を提出する → マシンリソースを自分で調達すれば計算時間にとらわれない、利用できる言語も自由 チーム人数が無制限 → 色んな役割の人をチームに入れられる の2点で、これによって何でもアリの楽しいコンテストになってます。
結果 17位でした。
前年の6位には及びませんでしたが、終了2時間前までは30位付近を彷徨っていたので、そう考えると良い成績なんじゃないかなと思います。
チームメンバー daiju：インフラ + ソルバー（ Rust ） omu：ビジュアライザ（ Rust ） sntea：ソルバー（ Rust ） 僕：ダッシュボード（ Typescript, Python ） 競プロガチ勢 の iwashi や nola_suz が抜けてソルバー書く人が不足してるんですが、助っ人として現れた sntea くんがつよつよで助かりました。
今年の問題 400x400 のエリアを分割 + 色塗りをしていって、目標の画像に近付けるという問題でした。
problem solution ただし分割や色塗りのコストがエリアが小さくなるほど高くなるような関数になっていて、如何に広いエリアを保ちつつ色を塗るかがポイントになる問題でした。
やったこと 事前準備 今年は Firebase 使おう！と決めていたので、アカウントの準備と、 Hosting Firestore Functions Authentication の素振りをしていました。
9/2(金) 問題読みつつ公式のシミュレータを使って手動解を書いたりするが辛くなってやめる 例年通り公式のスコアボードをハックしてランキングbotを作る 夜はしっかり寝る 9/3(土) 昼くらいにはダッシュボードにスコアが出るようになる omu シミュレータが動くようになっていたので画像を吐き出して imagemagick で gif にしてダッシュボードに組み込む sntea のグリーディー解と daiju の焼きなまし解でスコアを伸ばしていく submission をひたすらダッシュボードに反映する人間 CI と化す この日も夜はしっかり寝る 9/4(日) 継続的に人間 CI をやる ダッシュボードのコードを整えたり提出解を眺めたりする 色塗りが幾何平均になってコストが最適化されたり、 daiju がチェスボードを手動で解いたりする 公式のスコアボードにはチームごとの合計点しか出ていないが、APIでは問題ごとにスコアが返って来ていることに気付き、スコアボードを作る スコアボードを見た omu が今の方針じゃまずそうと気付き、大きなエリアで cut して color して merge みたいな手順が良さそう、と思い付く（ omu メソッドと呼ばれる） gitlab がタイミング悪くメンテナンスタイムに入ったりする この日も夜はしっかり寝る 9/5(月) 継続的に人間 CI をやる image と move のコストを分けて見たいという話になり、 omu シミュレータが吐き出したそれぞれのコストをダッシュボードに反映するようにする omu シミュレータを直すのに Rust を書くのに手こずったりする omu ビジュアライザ + omu メソッドで手動解を作る omu ビジュアライザで格子をマージする最適コストを探す 格子が切られている問題で格子をマージ + 前半の問題の解で解を作るスクリプトを書く 手動解で地道にスコアを上げていく 力作の手動解 daiju が omu メソッド + 探索のソルバーを書いたがスコア上がらず スコアボード凍結後に sntea の omu メソッド + DP のソルバーができあがりスコアが大幅に改善される 作ったもの レポジトリ https://gitlab.</description></item><item><title>ICFP-PC2019 参加記</title><link>https://akagenorobin.github.io/post/2019-07-12/</link><pubDate>Fri, 12 Jul 2019 00:00:00 +0000</pubDate><guid>https://akagenorobin.github.io/post/2019-07-12/</guid><description>今年も ICFP-PC に会社のチームで参加したので、参加記を書きます。
ICFP-PC とは 関数型プログラミング言語の国際学会 ICFP が主催する、チーム人数自由、言語も自由、な72時間耐久のプログラミングコンテストです。 僕は2017年の punter 、2018年の nanobot と参加して、今年が3回目になります。 今年は去年まで主戦力だったチームメイト2人が抜けてしまったため、去年までのチーム名である chirimenjako(ちりめんじゃこ) から h(飛車) と k(角) を抜いた cirimenjao(しりめんじゃお？) として参加しました。
今年の問題 二次元のマップ上を worker-wrapper というロボットが色を塗っていく、という問題でした。 マップ上にはブースターというアイテムが配置されており、それらを上手く使いこなして短時間で全域を塗りつぶすことが求められています。
ICFP-PC お馴染みの追加課題では、特定の条件に合うマップを作成するパズルと呼ばれる問題も出題されました。 僕は AI 部分にはあまり関わっていないので、詳細はチームメイトの記事に委ねます。
作ったもの 出来上がった AI を実行するインフラの作成、現在のランキングを通知する Slackbot の作成、今までのスコアの一覧を見れるようにするダッシュボードの作成、今までのベストスコアの解答を集めて提出するプログラムの作成、なんかをやってました。 色々作れて楽しかった～という感想ですが、割と去年と同じ感じのものを作っていたので、ちゃんと準備しておけばもっと色々やれたんじゃないか、という反省もあります。
AI 実行環境 以下の様な構成で CI を構築しました。
流れとしては以下のようになっています。
AI 開発者が Gitlab に コードを push gitlab-ci がそれを検知し gitlab-runner に投げる gitlab-runner がコードを zip 化し、300問分のタスクをキューに投げる 各ワーカがタスクを処理し結果を S3 に置く キューイングの部分は昨年チームメイトが作ったのを真似して celery と subprocess で書きました。 工夫した点としては
パイプラインの部分は別のメンバーが作ってくれていたので、 gitlab-runner からはスクリプトを一発実行するだけでタスクが飛ぶようにした celery は json エンコード可能な引数しか渡せない（頑張れば pickle とかも渡せる）のでプログラムは S3 に上げてワーカで落としてくるようにした 元々各タスク内でコンパイルしていたのをワーカ単位で最初の1回のみコンパイルするようにしたら飛躍的に速くなった などです。 普段業務で使い慣れている ElastiCache の redis を celery のバックエンドに使ったら、 AWS の利用料金が $39 くらいになってビビりました（2日目途中くらいに気付いて EC2 に切り替えました）。 下記を参考にしました。</description></item></channel></rss>